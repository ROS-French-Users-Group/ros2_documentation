# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, Open Robotics
# This file is distributed under the same license as the ROS 2 documentation package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: ROS 2 documentation\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-01-07 08:44+0100\n"
"PO-Revision-Date: 2023-01-07 14:07:49.095331\n"
"Last-Translator: potranslator 1.1.5\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Translated-By: potranslator 1.1.5\n"

#: ../../source/Concepts/About-Executors.rst:4
msgid "Executors"
msgstr "Exécuteurs"

#: ../../source/Concepts/About-Executors.rst:7
msgid "Table of Contents"
msgstr "Table des matières"

#: ../../source/Concepts/About-Executors.rst:10
msgid "Overview"
msgstr "Aperçu"

#: ../../source/Concepts/About-Executors.rst:12
msgid ""
"Execution management in ROS 2 is explicated by the concept of Executors. An "
"Executor uses one or more threads of the underlying operating system to "
"invoke the callbacks of subscriptions, timers, service servers, action "
"servers, etc. on incoming messages and events. The explicit Executor class "
"(in `executor.hpp "
"<https://github.com/ros2/rclcpp/blob/rolling/rclcpp/include/rclcpp/executor.hpp>`_"
" in rclcpp, in `executors.py "
"<https://github.com/ros2/rclpy/blob/rolling/rclpy/rclpy/executors.py>`_ in "
"rclpy, or in `executor.h "
"<https://github.com/ros2/rclc/blob/master/rclc/include/rclc/executor.h>`_ in"
" rclc) provides more control over execution management than the spin "
"mechanism in ROS 1, although the basic API is very similar."
msgstr ""
"La gestion de l'exécution dans ROS 2 est expliquée par le concept "
"d'exécuteurs. Un exécuteur utilise un ou plusieurs threads du système "
"d'exploitation sous-jacent pour invoquer les rappels des abonnements, des "
"temporisateurs, des serveurs de service, des serveurs d'action, etc. sur les"
" messages et événements entrants. La classe Executor explicite (dans "
"`executor.hpp "
"<https://github.com/ros2/rclcpp/blob/rolling/rclcpp/include/rclcpp/executor.hpp>`_"
" dans rclcpp, dans `executors.py <https: "
"//github.com/ros2/rclpy/blob/rolling/rclpy/rclpy/executors.py>`_ dans rclpy,"
" ou dans `executor.h <https://github.com/ros2/rclc/blob/master/ "
"rclc/include/rclc/executor.h>`_ dans rclc) fournit plus de contrôle sur la "
"gestion de l'exécution que le mécanisme de spin dans ROS 1, bien que l'API "
"de base soit très similaire."

#: ../../source/Concepts/About-Executors.rst:16
msgid "In the following, we focus on the C++ Client Library *rclcpp*."
msgstr ""
"Dans ce qui suit, nous nous concentrons sur la bibliothèque cliente C++ "
"*rclcpp*."

#: ../../source/Concepts/About-Executors.rst:19
msgid "Basic use"
msgstr "Utilisation de base"

#: ../../source/Concepts/About-Executors.rst:21
msgid ""
"In the simplest case, the main thread is used for processing the incoming "
"messages and events of a Node by calling ``rclcpp::spin(..)`` as follows:"
msgstr ""
"Dans le cas le plus simple, le thread principal est utilisé pour traiter les"
" messages entrants et les événements d'un nœud en appelant "
"``rclcpp::spin(..)`` comme suit :"

#: ../../source/Concepts/About-Executors.rst:42
msgid ""
"The call to ``spin(node)`` basically expands to an instantiation and "
"invocation of the Single-Threaded Executor, which is the simplest Executor:"
msgstr ""
"L'appel à ``spin(node)`` se développe essentiellement en une instanciation "
"et une invocation de l'exécuteur monothread, qui est l'exécuteur le plus "
"simple :"

#: ../../source/Concepts/About-Executors.rst:50
msgid ""
"By invoking ``spin()`` of the Executor instance, the current thread starts "
"querying the rcl and middleware layers for incoming messages and other "
"events and calls the corresponding callback functions until the node shuts "
"down. In order not to counteract the QoS settings of the middleware, an "
"incoming message is not stored in a queue on the Client Library layer but "
"kept in the middleware until it is taken for processing by a callback "
"function. (This is a crucial difference to ROS 1.) A *wait set* is used to "
"inform the Executor about available messages on the middleware layer, with "
"one binary flag per queue. The *wait set* is also used to detect when timers"
" expire."
msgstr ""
"En invoquant ``spin()`` de l'instance Executor, le thread actuel commence à "
"interroger les couches rcl et middleware pour les messages entrants et "
"autres événements et appelle les fonctions de rappel correspondantes jusqu'à"
" ce que le nœud s'arrête. Afin de ne pas contrecarrer les paramètres QoS du "
"middleware, un message entrant n'est pas stocké dans une file d'attente sur "
"la couche Client Library mais conservé dans le middleware jusqu'à ce qu'il "
"soit pris en charge par une fonction de rappel. (Il s'agit d'une différence "
"cruciale avec ROS 1.) Un *wait set* est utilisé pour informer l'exécuteur "
"des messages disponibles sur la couche middleware, avec un indicateur "
"binaire par file d'attente. Le *wait set* est également utilisé pour "
"détecter l'expiration des minuteries."

#: ../../source/Concepts/About-Executors.rst:58
msgid ""
"The Single-Threaded Executor is also used by the container process for "
":doc:`components <./About-Composition>`, i.e. in all cases where nodes are "
"created and executed without an explicit main function."
msgstr ""
"L'exécuteur monothread est également utilisé par le processus conteneur pour"
" :doc:`components <./About-Composition>`, c'est-à-dire dans tous les cas où "
"des nœuds sont créés et exécutés sans fonction principale explicite."

#: ../../source/Concepts/About-Executors.rst:61
msgid "Types of Executors"
msgstr "Types d'exécuteurs"

#: ../../source/Concepts/About-Executors.rst:63
msgid ""
"Currently, rclcpp provides three Executor types, derived from a shared "
"parent class:"
msgstr ""
"Actuellement, rclcpp fournit trois types d'exécuteurs, dérivés d'une classe "
"parent partagée :"

#: ../../source/Concepts/About-Executors.rst:79
msgid ""
"The *Multi-Threaded Executor* creates a configurable number of threads to "
"allow for processing multiple messages or events in parallel. The *Static "
"Single-Threaded Executor* optimizes the runtime costs for scanning the "
"structure of a node in terms of subscriptions, timers, service servers, "
"action servers, etc. It performs this scan only once when the node is added,"
" while the other two executors regularly scan for such changes. Therefore, "
"the Static Single-Threaded Executor should be used only with nodes that "
"create all subscriptions, timers, etc. during initialization."
msgstr ""
"* L'exécuteur multithread * crée un nombre configurable de threads pour "
"permettre le traitement de plusieurs messages ou événements en parallèle. Le"
" *Static Single-Threaded Executor* optimise les coûts d'exécution pour "
"scanner la structure d'un nœud en termes d'abonnements, de temporisateurs, "
"de serveurs de service, de serveurs d'action, etc. Il effectue ce scan une "
"seule fois lorsque le nœud est ajouté, tandis que les deux autres les "
"exécuteurs recherchent régulièrement de tels changements. Par conséquent, "
"l'exécuteur statique à un seul thread ne doit être utilisé qu'avec des nœuds"
" qui créent tous les abonnements, temporisateurs, etc. lors de "
"l'initialisation."

#: ../../source/Concepts/About-Executors.rst:84
msgid ""
"All three executors can be used with multiple nodes by calling "
"``add_node(..)`` for each node."
msgstr ""
"Les trois exécuteurs peuvent être utilisés avec plusieurs nœuds en appelant "
"``add_node(..)`` pour chaque nœud."

#: ../../source/Concepts/About-Executors.rst:98
msgid ""
"In the above example, the one thread of a Static Single-Threaded Executor is"
" used to serve three nodes together. In case of a Multi-Threaded Executor, "
"the actual parallelism depends on the callback groups."
msgstr ""
"Dans l'exemple ci-dessus, le seul thread d'un exécuteur statique à un seul "
"thread est utilisé pour desservir trois nœuds ensemble. Dans le cas d'un "
"exécuteur multithread, le parallélisme réel dépend des groupes de rappel."

#: ../../source/Concepts/About-Executors.rst:102
msgid "Callback groups"
msgstr "Groupes de rappel"

#: ../../source/Concepts/About-Executors.rst:104
msgid ""
"ROS 2 allows organizing the callbacks of a node in groups. In rclcpp, such a"
" *callback group* can be created by the ``create_callback_group`` function "
"of the Node class. In rclpy, the same is done by calling the constructor of "
"the specific callback group type. The callback group must be stored "
"throughout execution of the node (eg. as a class member), or otherwise the "
"executor won't be able to trigger the callbacks. Then, this callback group "
"can be specified when creating a subscription, timer, etc. - for example by "
"the subscription options:"
msgstr ""
"ROS 2 permet d'organiser les rappels d'un nœud en groupes. Dans rclcpp, un "
"tel *groupe de rappel* peut être créé par la fonction "
"``create_callback_group`` de la classe Node. Dans rclpy, la même chose est "
"faite en appelant le constructeur du type de groupe de rappel spécifique. Le"
" groupe de rappel doit être stocké tout au long de l'exécution du nœud (par "
"exemple en tant que membre de classe), sinon l'exécuteur ne pourra pas "
"déclencher les rappels. Ensuite, ce groupe de rappel peut être spécifié lors"
" de la création d'un abonnement, d'un timer, etc. - par exemple par les "
"options d'abonnement :"

#: ../../source/Concepts/About-Executors.rst:112
msgid "C++"
msgstr "C++"

#: ../../source/Concepts/About-Executors.rst:123
msgid "Python"
msgstr "Python"

#: ../../source/Concepts/About-Executors.rst:131
msgid ""
"All subscriptions, timers, etc. that are created without the indication of a"
" callback group are assigned to the *default callback group*. The default "
"callback group can be queried via "
"``NodeBaseInterface::get_default_callback_group()`` in rclcpp and by "
"``Node.default_callback_group`` in rclpy."
msgstr ""
"Tous les abonnements, minuteries, etc. qui sont créés sans l'indication d'un"
" groupe de rappel sont affectés au *groupe de rappel par défaut*. Le groupe "
"de rappel par défaut peut être interrogé via "
"``NodeBaseInterface::get_default_callback_group()`` dans rclcpp et par "
"``Node.default_callback_group`` dans rclpy."

#: ../../source/Concepts/About-Executors.rst:135
msgid ""
"There are two types of callback groups, where the type has to be specified "
"at instantiation time:"
msgstr ""
"Il existe deux types de groupes de rappel, où le type doit être spécifié au "
"moment de l'instanciation :"

#: ../../source/Concepts/About-Executors.rst:137
msgid ""
"*Mutually exclusive:* Callbacks of this group must not be executed in "
"parallel."
msgstr ""
"*Mutuellement exclusif :* Les rappels de ce groupe ne doivent pas être "
"exécutés en parallèle."

#: ../../source/Concepts/About-Executors.rst:138
msgid "*Reentrant:* Callbacks of this group may be executed in parallel."
msgstr ""
"*Réentrant :* Les rappels de ce groupe peuvent être exécutés en parallèle."

#: ../../source/Concepts/About-Executors.rst:140
msgid ""
"Callbacks of different callback groups may always be executed in parallel. "
"The Multi-Threaded Executor uses its threads as a pool to process a many "
"callbacks as possible in parallel according to these conditions. For tips on"
" how to use callback groups efficiently, see :doc:`Using Callback Groups "
"<../How-To-Guides/Using-callback-groups>`."
msgstr ""
"Les rappels de différents groupes de rappel peuvent toujours être exécutés "
"en parallèle. L'exécuteur multithread utilise ses threads comme un pool pour"
" traiter autant de rappels que possible en parallèle selon ces conditions. "
"Pour obtenir des conseils sur l'utilisation efficace des groupes de rappel, "
"consultez :doc:`Using Callback Groups <../How-To-Guides/Using-callback-"
"groups>`."

#: ../../source/Concepts/About-Executors.rst:144
msgid ""
"The Executor base class in rclcpp also has the function "
"``add_callback_group(..)``, which allows distributing callback groups to "
"different Executors. By configuring the underlying threads using the "
"operating system scheduler, specific callbacks can be prioritized over other"
" callbacks. For example, the subscriptions and timers of a control loop can "
"be prioritized over all other subscriptions and standard services of a node."
" The `examples_rclcpp_cbg_executor package "
"<https://github.com/ros2/examples/tree/rolling/rclcpp/executors/cbg_executor>`_"
" provides a demo of this mechanism."
msgstr ""
"La classe de base Executor dans rclcpp a également la fonction "
"``add_callback_group(..)``, qui permet de distribuer des groupes de rappel à"
" différents Executors. En configurant les threads sous-jacents à l'aide du "
"planificateur du système d'exploitation, des rappels spécifiques peuvent "
"être prioritaires sur d'autres rappels. Par exemple, les abonnements et les "
"temporisateurs d'une boucle de contrôle peuvent être prioritaires sur tous "
"les autres abonnements et services standard d'un nœud. Le package "
"`examples_rclcpp_cbg_executor "
"<https://github.com/ros2/examples/tree/rolling/rclcpp/executors/cbg_executor>`_"
" fournit une démonstration de ce mécanisme."

#: ../../source/Concepts/About-Executors.rst:150
msgid "Scheduling semantics"
msgstr "Sémantique de planification"

#: ../../source/Concepts/About-Executors.rst:152
msgid ""
"If the processing time of the callbacks is shorter than the period with "
"which messages and events occur, the Executor basically processes them in "
"FIFO order. However, if the processing time of some callbacks is longer, "
"messages and events will be queued on the lower layers of the stack. The "
"wait set mechanism reports only very little information about these queues "
"to the Executor. In detail, it only reports whether there are any messages "
"for a certain topic or not. The Executor uses this information to process "
"the messages (including services and actions) in a round-robin fashion - but"
" not in FIFO order. The following flow diagram visualizes this scheduling "
"semantics."
msgstr ""
"Si le temps de traitement des rappels est plus court que la période pendant "
"laquelle les messages et les événements se produisent, l'exécuteur les "
"traite essentiellement dans l'ordre FIFO. Cependant, si le temps de "
"traitement de certains rappels est plus long, les messages et les événements"
" seront mis en file d'attente sur les couches inférieures de la pile. Le "
"mécanisme d'ensemble d'attente ne rapporte que très peu d'informations sur "
"ces files d'attente à l'exécuteur. En détail, il signale uniquement s'il y a"
" des messages pour un certain sujet ou non. L'exécuteur utilise ces "
"informations pour traiter les messages (y compris les services et les "
"actions) de manière circulaire - mais pas dans l'ordre FIFO. L'organigramme "
"suivant visualise cette sémantique de planification."

#: ../../source/Concepts/About-Executors.rst:161
msgid ""
"This semantics was first described in a `paper by Casini et al. at ECRTS "
"2019 <https://drops.dagstuhl.de/opus/volltexte/2019/10743/pdf/LIPIcs-"
"ECRTS-2019-6.pdf>`_. (Note: The paper also explains that timer events are "
"prioritized over all other messages. `This prioritization was removed in "
"Eloquent. <https://github.com/ros2/rclcpp/pull/841>`_)"
msgstr ""
"Cette sémantique a été décrite pour la première fois dans un article de "
"Casini et al. à l'ECRTS 2019 "
"<https://drops.dagstuhl.de/opus/volltexte/2019/10743/pdf/LIPics-"
"ECRTS-2019-6.pdf>`_. (Remarque : le document explique également que les "
"événements de minuterie sont prioritaires sur tous les autres messages. "
"`Cette hiérarchisation a été supprimée dans Eloquent. "
"<https://github.com/ros2/rclcpp/pull/841>`_)"

#: ../../source/Concepts/About-Executors.rst:166
msgid "Outlook"
msgstr "Perspectives"

#: ../../source/Concepts/About-Executors.rst:168
msgid ""
"While the three Executors of rclcpp work well for most applications there "
"are some issues that make them not suitable for real-time applications, "
"which require well-defined execution times, determinism, and custom control "
"over the execution order. Here is a summary of some of these issues:"
msgstr ""
"Bien que les trois exécuteurs de rclcpp fonctionnent bien pour la plupart "
"des applications, certains problèmes les rendent inadaptés aux applications "
"en temps réel, qui nécessitent des temps d'exécution bien définis, un "
"déterminisme et un contrôle personnalisé sur l'ordre d'exécution. Voici un "
"résumé de certains de ces problèmes :"

#: ../../source/Concepts/About-Executors.rst:171
msgid ""
"Complex and mixed scheduling semantics. Ideally you want well defined "
"scheduling semantics to perform a formal timing analysis."
msgstr ""
"Sémantique d'ordonnancement complexe et mixte. Idéalement, vous souhaitez "
"une sémantique de planification bien définie pour effectuer une analyse "
"temporelle formelle."

#: ../../source/Concepts/About-Executors.rst:173
msgid ""
"Callbacks may suffer from priority inversion. Higher priority callbacks may "
"be blocked by lower priority callbacks."
msgstr ""
"Les rappels peuvent souffrir d'une inversion de priorité. Les rappels de "
"priorité supérieure peuvent être bloqués par des rappels de priorité "
"inférieure."

#: ../../source/Concepts/About-Executors.rst:175
msgid "No explicit control over the callbacks execution order."
msgstr "Aucun contrôle explicite sur l'ordre d'exécution des rappels."

#: ../../source/Concepts/About-Executors.rst:176
msgid "No built-in control over triggering for specific topics."
msgstr ""
"Aucun contrôle intégré sur le déclenchement pour des sujets spécifiques."

#: ../../source/Concepts/About-Executors.rst:178
msgid ""
"Additionally, the executor overhead in terms of CPU and memory usage is "
"considerable. The Static Single-Threaded Executor reduces this overhead "
"greatly but it might be not enough for some applications."
msgstr ""
"De plus, la surcharge de l'exécuteur en termes d'utilisation du processeur "
"et de la mémoire est considérable. L'exécuteur statique à un seul thread "
"réduit considérablement cette surcharge, mais cela peut ne pas être "
"suffisant pour certaines applications."

#: ../../source/Concepts/About-Executors.rst:181
msgid ""
"These issues have been partially addressed by the following developments:"
msgstr ""
"Ces problèmes ont été partiellement résolus par les développements suivants "
":"

#: ../../source/Concepts/About-Executors.rst:183
msgid ""
"`rclcpp WaitSet "
"<https://github.com/ros2/rclcpp/blob/rolling/rclcpp/include/rclcpp/wait_set.hpp>`_:"
" The ``WaitSet`` class of rclcpp allows waiting directly on subscriptions, "
"timers, service servers, action servers, etc. instead of using an Executor. "
"It can be used to implement deterministic, user-defined processing "
"sequences, possibly processing multiple messages from different "
"subscriptions together. The `examples_rclcpp_wait_set package "
"<https://github.com/ros2/examples/tree/rolling/rclcpp/wait_set>`_ provides "
"several examples for the use of this user-level wait set mechanism."
msgstr ""
"`rclcpp WaitSet "
"<https://github.com/ros2/rclcpp/blob/rolling/rclcpp/include/rclcpp/wait_set.hpp>`_ :"
" La classe ``WaitSet`` de rclcpp permet d'attendre directement sur les "
"abonnements, les minuteurs, serveurs de service, serveurs d'action, etc. au "
"lieu d'utiliser un exécuteur. Il peut être utilisé pour implémenter des "
"séquences de traitement déterministes définies par l'utilisateur, traitant "
"éventuellement plusieurs messages provenant de différents abonnements "
"ensemble. Le package `examples_rclcpp_wait_set "
"<https://github.com/ros2/examples/tree/rolling/rclcpp/wait_set>`_ fournit "
"plusieurs exemples d'utilisation de ce mécanisme de jeu d'attente au niveau "
"de l'utilisateur."

#: ../../source/Concepts/About-Executors.rst:186
msgid ""
"`rclc Executor "
"<https://github.com/ros2/rclc/blob/master/rclc/include/rclc/executor.h>`_: "
"This Executor from the C Client Library *rclc* developed for micro-ROS gives"
" the user fine-grained control over the execution order of callbacks and "
"allows for custom trigger conditions to activate callbacks. Furthermore, it "
"implements ideas of the Logical Execution Time (LET) semantics."
msgstr ""
"`rclc Executor "
"<https://github.com/ros2/rclc/blob/master/rclc/include/rclc/executor.h>`_ : "
"cet exécuteur de la bibliothèque client C *rclc* développé pour micro-ROS "
"donne le contrôle précis de l'utilisateur sur l'ordre d'exécution des "
"rappels et permet des conditions de déclenchement personnalisées pour "
"activer les rappels. De plus, il implémente les idées de la sémantique du "
"temps d'exécution logique (LET)."

#: ../../source/Concepts/About-Executors.rst:190
msgid "Further information"
msgstr "Plus d'informations"

#: ../../source/Concepts/About-Executors.rst:192
msgid ""
"Michael Pöhnl et al.: `\"ROS 2 Executor: How to make it efficient, real-time"
" and deterministic?\" <https://www.apex.ai/roscon-21>`_. Workshop at ROS "
"World 2021. Virtual event. 19 October 2021."
msgstr ""
"Michael Pöhnl et al. : `« Exécuteur ROS 2 : comment le rendre efficace, "
"temps réel et déterministe ? <https://www.apex.ai/roscon-21>`_. Atelier au "
"ROS World 2021. Événement virtuel. 19 octobre 2021."

#: ../../source/Concepts/About-Executors.rst:193
msgid ""
"Ralph Lange: `\"Advanced Execution Management with ROS 2\" "
"<https://www.youtube.com/watch?v=Sz-nllmtcc8&t=109s>`_. ROS Industrial "
"Conference. Virtual event. 16 December 2020."
msgstr ""
"Ralph Lange : `\"Gestion avancée de l'exécution avec ROS 2\" "
"<https://www.youtube.com/watch?v=Sz-nllmtcc8&t=109s>`_. Conférence "
"industrielle ROS. Événement virtuel. 16 décembre 2020."

#: ../../source/Concepts/About-Executors.rst:194
msgid ""
"Daniel Casini, Tobias Blass, Ingo Lütkebohle, and Björn Brandenburg: "
"`“Response-Time Analysis of ROS 2 Processing Chains under Reservation-Based "
"Scheduling” <https://drops.dagstuhl.de/opus/volltexte/2019/10743/pdf/LIPIcs-"
"ECRTS-2019-6.pdf>`_, Proc. of 31st ECRTS 2019, Stuttgart, Germany, July "
"2019."
msgstr ""
"Daniel Casini, Tobias Blass, Ingo Lütkebohle et Björn Brandenburg : "
"`\"Analyse du temps de réponse des chaînes de traitement ROS 2 sous la "
"planification basée sur les réservations\" "
"<https://drops.dagstuhl.de/opus/volltexte/2019/10743/pdf /LIPics-"
"ECRTS-2019-6.pdf>`_, Proc. du 31e ECRTS 2019, Stuttgart, Allemagne, juillet "
"2019."
