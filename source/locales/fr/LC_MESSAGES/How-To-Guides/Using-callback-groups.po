# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, Open Robotics
# This file is distributed under the same license as the ROS 2 documentation package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: ROS 2 documentation\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-01-07 08:44+0100\n"
"PO-Revision-Date: 2023-01-07 17:22:28.935690\n"
"Last-Translator: potranslator 1.1.5\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Translated-By: potranslator 1.1.5\n"

#: ../../source/How-To-Guides/Using-callback-groups.rst:2
msgid "Using Callback Groups"
msgstr "Utilisation des groupes de rappel"

#: ../../source/How-To-Guides/Using-callback-groups.rst:4
msgid ""
"When running a node in a Multi-Threaded Executor, ROS 2 offers callback "
"groups as a tool for controlling the execution of different callbacks. This "
"page is meant as a guide on how to use callback groups efficiently. It is "
"assumed that the reader has a basic understanding about the concept of "
":doc:`executors <../Concepts/About-Executors>`."
msgstr ""
"Lors de l'exécution d'un nœud dans un exécuteur multithread, ROS 2 propose "
"des groupes de rappel comme outil pour contrôler l'exécution de différents "
"rappels. Cette page est conçue comme un guide sur la façon d'utiliser "
"efficacement les groupes de rappel. Il est supposé que le lecteur a une "
"compréhension de base du concept de :doc:`executors <../Concepts/About-"
"Executors>`."

#: ../../source/How-To-Guides/Using-callback-groups.rst:11
msgid "Table of Contents"
msgstr "Table des matières"

#: ../../source/How-To-Guides/Using-callback-groups.rst:14
msgid "Basics of callback groups"
msgstr "Principes de base des groupes de rappel"

#: ../../source/How-To-Guides/Using-callback-groups.rst:16
msgid ""
"When running a node in a Multi-Threaded Executor, ROS 2 offers two different"
" types of callback groups for controlling execution of callbacks:"
msgstr ""
"Lors de l'exécution d'un nœud dans un exécuteur multithread, ROS 2 propose "
"deux types différents de groupes de rappel pour contrôler l'exécution des "
"rappels :"

#: ../../source/How-To-Guides/Using-callback-groups.rst:20
msgid "Mutually Exclusive Callback Group"
msgstr "Groupe de rappel mutuellement exclusif"

#: ../../source/How-To-Guides/Using-callback-groups.rst:21
msgid "Reentrant Callback Group"
msgstr "Groupe de rappel réentrant"

#: ../../source/How-To-Guides/Using-callback-groups.rst:23
msgid ""
"These callback groups restrict the execution of their callbacks in different"
" ways. In short:"
msgstr ""
"Ces groupes de rappel limitent l'exécution de leurs rappels de différentes "
"manières. En bref:"

#: ../../source/How-To-Guides/Using-callback-groups.rst:27
msgid ""
"Mutually Exclusive Callback Group prevents its callbacks from being executed"
" in parallel - essentially making it as if the callbacks in the group were "
"executed by a SingleThreadedExecutor."
msgstr ""
"Le groupe de rappel mutuellement exclusif empêche l'exécution de ses rappels"
" en parallèle, ce qui fait essentiellement comme si les rappels du groupe "
"étaient exécutés par un SingleThreadedExecutor."

#: ../../source/How-To-Guides/Using-callback-groups.rst:30
msgid ""
"Reentrant Callback Group allows the executor to schedule and execute the "
"group's callbacks in any way the it sees fit, without restrictions. This "
"means that, in addition to different callbacks being run parallel to each "
"other, different instances of the same callback may also be executed "
"concurrently."
msgstr ""
"Le groupe de rappel réentrant permet à l'exécuteur de programmer et "
"d'exécuter les rappels du groupe de la manière qu'il juge appropriée, sans "
"restrictions. Cela signifie qu'en plus des différents rappels exécutés "
"parallèlement les uns aux autres, différentes instances du même rappel "
"peuvent également être exécutées simultanément."

#: ../../source/How-To-Guides/Using-callback-groups.rst:35
msgid ""
"Callbacks belonging to different callback groups (of any type) can always be"
" executed parallel to each other."
msgstr ""
"Les rappels appartenant à différents groupes de rappel (de tout type) "
"peuvent toujours être exécutés parallèlement les uns aux autres."

#: ../../source/How-To-Guides/Using-callback-groups.rst:38
msgid ""
"It is also important to keep in mind that different ROS 2 entities relay "
"their callback group to all callbacks they spawn. For example, if one "
"assigns a callback group to an action client, all callbacks created by the "
"client will be assigned to that callback group."
msgstr ""
"Il est également important de garder à l'esprit que différentes entités ROS "
"2 relaient leur groupe de rappel à tous les rappels qu'elles génèrent. Par "
"exemple, si l'on affecte un groupe de rappel à un client d'action, tous les "
"rappels créés par le client seront affectés à ce groupe de rappel."

#: ../../source/How-To-Guides/Using-callback-groups.rst:43
msgid ""
"Callback groups can be created by a node's ``create_callback_group`` "
"function in rclcpp and by calling the constructor of the group in rclpy. The"
" callback group can then be passed as argument/option when creating a "
"subscription, timer, etc."
msgstr ""
"Les groupes de rappel peuvent être créés par la fonction "
"``create_callback_group`` d'un nœud dans rclcpp et en appelant le "
"constructeur du groupe dans rclpy. Le groupe de rappel peut ensuite être "
"passé en argument/option lors de la création d'un abonnement, d'un timer, "
"etc."

#: ../../source/How-To-Guides/Using-callback-groups.rst:49
#: ../../source/How-To-Guides/Using-callback-groups.rst:193
#: ../../source/How-To-Guides/Using-callback-groups.rst:279
#: ../../source/How-To-Guides/Using-callback-groups.rst:445
#: ../../source/How-To-Guides/Using-callback-groups.rst:499
#: ../../source/How-To-Guides/Using-callback-groups.rst:522
msgid "C++"
msgstr "C++"

#: ../../source/How-To-Guides/Using-callback-groups.rst:61
#: ../../source/How-To-Guides/Using-callback-groups.rst:245
#: ../../source/How-To-Guides/Using-callback-groups.rst:344
#: ../../source/How-To-Guides/Using-callback-groups.rst:452
#: ../../source/How-To-Guides/Using-callback-groups.rst:506
#: ../../source/How-To-Guides/Using-callback-groups.rst:550
msgid "Python"
msgstr "Python"

#: ../../source/How-To-Guides/Using-callback-groups.rst:69
msgid ""
"If the user does not specify any callback group when creating a "
"subscription, timer, etc., this entity will be assigned to the node's "
"default callback group. The default callback group is a Mutually Exclusive "
"Callback Group and it can be queried via "
"``NodeBaseInterface::get_default_callback_group()`` in rclcpp and via "
"``Node.default_callback_group`` in rclpy."
msgstr ""
"Si l'utilisateur ne spécifie aucun groupe de rappel lors de la création d'un"
" abonnement, d'une minuterie, etc., cette entité sera affectée au groupe de "
"rappel par défaut du nœud. Le groupe de rappel par défaut est un groupe de "
"rappel mutuellement exclusif et il peut être interrogé via "
"``NodeBaseInterface::get_default_callback_group()`` dans rclcpp et via "
"``Node.default_callback_group`` dans rclpy."

#: ../../source/How-To-Guides/Using-callback-groups.rst:76
msgid "About callbacks"
msgstr "À propos des rappels"

#: ../../source/How-To-Guides/Using-callback-groups.rst:78
msgid ""
"In the context of ROS 2 and executors, a callback means a function whose "
"scheduling and execution is handled by an executor. Examples of callbacks in"
" this context are"
msgstr ""
"Dans le contexte de ROS 2 et des exécuteurs, un rappel signifie une fonction"
" dont la planification et l'exécution sont gérées par un exécuteur. Des "
"exemples de rappels dans ce contexte sont"

#: ../../source/How-To-Guides/Using-callback-groups.rst:82
msgid "subscription callbacks (receiving and handling data from a topic),"
msgstr ""
"rappels d'abonnement (réception et traitement des données d'un sujet),"

#: ../../source/How-To-Guides/Using-callback-groups.rst:83
msgid "timer callbacks,"
msgstr "rappels de minuterie,"

#: ../../source/How-To-Guides/Using-callback-groups.rst:84
msgid "service callbacks (for executing service requests in a server),"
msgstr ""
"les rappels de service (pour exécuter des demandes de service dans un "
"serveur),"

#: ../../source/How-To-Guides/Using-callback-groups.rst:85
msgid "different callbacks in action servers and clients,"
msgstr "différents rappels dans les serveurs d'action et les clients,"

#: ../../source/How-To-Guides/Using-callback-groups.rst:86
msgid "done-callbacks of Futures."
msgstr "done-rappels de Futures."

#: ../../source/How-To-Guides/Using-callback-groups.rst:88
msgid ""
"Below are a couple important points about callbacks that should be kept in "
"mind when working with callback groups."
msgstr ""
"Vous trouverez ci-dessous quelques points importants concernant les rappels "
"à garder à l'esprit lorsque vous travaillez avec des groupes de rappel."

#: ../../source/How-To-Guides/Using-callback-groups.rst:91
msgid ""
"Almost everything in ROS 2 is a callback! Every function that is run by an "
"executor is, by definition, a callback. The non-callback functions in a ROS "
"2 system are found mainly at the edge of the system (user and sensor inputs "
"etc)."
msgstr ""
"Presque tout dans ROS 2 est un rappel ! Chaque fonction exécutée par un "
"exécuteur est, par définition, un rappel. Les fonctions de non-rappel dans "
"un système ROS 2 se trouvent principalement à la périphérie du système "
"(entrées utilisateur et capteur, etc.)."

#: ../../source/How-To-Guides/Using-callback-groups.rst:95
msgid ""
"Sometimes the callbacks are hidden and their presence may not be obvious "
"from the user/developer API. This is the case especially with any kind of "
"“synchronous” call to a service or an action (in rclpy). For example, the "
"synchronous call ``Client.call(request)`` to a service adds a Future's done-"
"callback that needs to be executed during the execution of the function "
"call, but this callback is not directly visible to the user."
msgstr ""
"Parfois, les rappels sont masqués et leur présence peut ne pas être évidente"
" à partir de l'API utilisateur/développeur. C'est le cas notamment de tout "
"type d'appel « synchrone » à un service ou à une action (en rclpy). Par "
"exemple, l'appel synchrone ``Client.call(request)`` à un service ajoute un "
"rappel terminé de Future qui doit être exécuté lors de l'exécution de "
"l'appel de la fonction, mais ce rappel n'est pas directement visible par "
"l'utilisateur."

#: ../../source/How-To-Guides/Using-callback-groups.rst:106
msgid "Controlling execution"
msgstr "Contrôler l'exécution"

#: ../../source/How-To-Guides/Using-callback-groups.rst:108
msgid ""
"In order to control execution with callback groups, one can consider the "
"following guidelines."
msgstr ""
"Afin de contrôler l'exécution avec des groupes de rappel, on peut considérer"
" les directives suivantes."

#: ../../source/How-To-Guides/Using-callback-groups.rst:111
msgid ""
"Register callbacks that should never be executed in parallel to the same "
"Mutually Exclusive Callback Group. An example case might be that the "
"callbacks are accessing shared critical and non-thread-safe resources."
msgstr ""
"Enregistrez les rappels qui ne doivent jamais être exécutés en parallèle sur"
" le même groupe de rappel mutuellement exclusif. Un exemple de cas peut être"
" que les rappels accèdent à des ressources partagées critiques et non "
"thread-safe."

#: ../../source/How-To-Guides/Using-callback-groups.rst:115
msgid ""
"If you have a callback whose execution instances need to be able to overlap "
"with each other, register it to a Reentrant Callback Group. An example case "
"could be an action server that needs to be able to process several action "
"calls in parallel to each other."
msgstr ""
"Si vous avez un rappel dont les instances d'exécution doivent pouvoir se "
"chevaucher, enregistrez-le dans un groupe de rappel réentrant. Un exemple de"
" cas pourrait être un serveur d'action qui doit être capable de traiter "
"plusieurs appels d'action en parallèle les uns aux autres."

#: ../../source/How-To-Guides/Using-callback-groups.rst:119
msgid ""
"If you have different callbacks that require to be potentially executed in "
"parallel to one another, register them to"
msgstr ""
"Si vous avez différents rappels qui doivent être potentiellement exécutés en"
" parallèle, enregistrez-les dans"

#: ../../source/How-To-Guides/Using-callback-groups.rst:122
msgid "a Reentrant Callback Group, or"
msgstr "un groupe de rappel réentrant, ou"

#: ../../source/How-To-Guides/Using-callback-groups.rst:123
msgid ""
"different Mutually Exclusive Callback Groups (this option is good if you "
"want the callbacks to not overlap themselves or also need thread safety with"
" respect to some other callbacks) or different callback groups of any type "
"(choose the types according to other criteria)."
msgstr ""
"différents groupes de rappel mutuellement exclusifs (cette option est utile "
"si vous souhaitez que les rappels ne se chevauchent pas ou si vous avez "
"également besoin de la sécurité des threads par rapport à d'autres rappels) "
"ou différents groupes de rappel de tout type (choisissez les types en "
"fonction d'autres critères)."

#: ../../source/How-To-Guides/Using-callback-groups.rst:129
msgid ""
"Note that the option in the list is a valid way of allowing parallel "
"execution for different callbacks, and can even be more desirable than "
"simply registering everything into one Reentrant Callback Group."
msgstr ""
"Notez que l'option dans la liste est un moyen valide d'autoriser l'exécution"
" parallèle pour différents rappels, et peut même être plus souhaitable que "
"de simplement tout enregistrer dans un groupe de rappel réentrant."

#: ../../source/How-To-Guides/Using-callback-groups.rst:134
msgid "Avoiding deadlocks"
msgstr "Éviter les blocages"

#: ../../source/How-To-Guides/Using-callback-groups.rst:136
msgid ""
"Setting up callback groups of a node incorrectly can lead to deadlocks (or "
"other unwanted behavior), especially if one desires to use synchronous calls"
" to services or actions. Indeed, even the API documentation of ROS 2 "
"mentions that synchronous calls to actions or services should not be done in"
" callbacks, because it can lead to deadlocks. While using asynchronous calls"
" is indeed safer in this regard, synchronous calls can also be made to work."
" On the other hand, synchronous calls also have their advantages, such as "
"making the code simpler and easier to understand. Hence, this section "
"provides some guidelines on how to set up a node's callback groups correctly"
" in order to avoid deadlocks."
msgstr ""
"La configuration incorrecte des groupes de rappel d'un nœud peut entraîner "
"des blocages (ou d'autres comportements indésirables), en particulier si "
"l'on souhaite utiliser des appels synchrones à des services ou des actions. "
"En effet, même la documentation de l'API de ROS 2 mentionne que les appels "
"synchrones à des actions ou à des services ne doivent pas se faire dans les "
"rappels, car cela peut conduire à des blocages. Bien que l'utilisation "
"d'appels asynchrones soit en effet plus sûre à cet égard, les appels "
"synchrones peuvent également fonctionner. D'un autre côté, les appels "
"synchrones ont aussi leurs avantages, comme rendre le code plus simple et "
"plus facile à comprendre. Par conséquent, cette section fournit des "
"directives sur la manière de configurer correctement les groupes de rappel "
"d'un nœud afin d'éviter les blocages."

#: ../../source/How-To-Guides/Using-callback-groups.rst:149
msgid ""
"First thing to note here is that every node's default callback group is a "
"Mutually Exclusive Callback Group. If the user does not specify any other "
"callback group when creating a timer, subscription, client etc., any "
"callbacks created then or later by these entities will use the node's "
"default callback group. Furthermore, if everything in a node uses the same "
"Mutually Exclusive Callback Group, that node essentially acts as if it was "
"handled by a Single-Threaded Executor, even if a multi-threaded one is "
"specified! Thus, whenever one decides to use a Multi-Threaded Executor, some"
" callback group(s) should always be specified in order for the executor "
"choice to make sense."
msgstr ""
"La première chose à noter ici est que le groupe de rappel par défaut de "
"chaque nœud est un groupe de rappel mutuellement exclusif. Si l'utilisateur "
"ne spécifie aucun autre groupe de rappel lors de la création d'un "
"temporisateur, d'un abonnement, d'un client, etc., tous les rappels créés "
"alors ou ultérieurement par ces entités utiliseront le groupe de rappel par "
"défaut du nœud. De plus, si tout dans un nœud utilise le même groupe de "
"rappel mutuellement exclusif, ce nœud agit essentiellement comme s'il était "
"géré par un exécuteur monothread, même si un exécuteur multithread est "
"spécifié ! Ainsi, chaque fois que l'on décide d'utiliser un exécuteur "
"multithread, un ou plusieurs groupes de rappel doivent toujours être "
"spécifiés pour que le choix de l'exécuteur ait un sens."

#: ../../source/How-To-Guides/Using-callback-groups.rst:161
msgid ""
"With the above in mind, here are a couple guidelines to help avoid "
"deadlocks:"
msgstr ""
"En gardant ce qui précède à l'esprit, voici quelques lignes directrices pour"
" éviter les blocages :"

#: ../../source/How-To-Guides/Using-callback-groups.rst:163
msgid ""
"If you make a synchronous call in any type of a callback, this callback and "
"the client making the call need to belong to"
msgstr ""
"Si vous effectuez un appel synchrone dans n'importe quel type de rappel, ce "
"rappel et le client effectuant l'appel doivent appartenir à"

#: ../../source/How-To-Guides/Using-callback-groups.rst:166
msgid "different callback groups (of any type), or"
msgstr "différents groupes de rappel (de tout type), ou"

#: ../../source/How-To-Guides/Using-callback-groups.rst:167
msgid "a Reentrant Callback Group."
msgstr "un groupe de rappel réentrant."

#: ../../source/How-To-Guides/Using-callback-groups.rst:169
msgid ""
"If the above configuration is not possible due to other requirements - such "
"as thread-safety and/or blocking of other callbacks while waiting for the "
"result (or if you want to make absolutely sure that there is never a "
"possibility of a deadlock), use asynchronous calls."
msgstr ""
"Si la configuration ci-dessus n'est pas possible en raison d'autres "
"exigences - telles que la sécurité des threads et/ou le blocage d'autres "
"rappels en attendant le résultat (ou si vous voulez être absolument sûr "
"qu'il n'y a jamais de possibilité de blocage), utilisez appels asynchrones."

#: ../../source/How-To-Guides/Using-callback-groups.rst:174
msgid ""
"Failing the first point will always cause a deadlock. An example of such a "
"case would be making a synchronous service call in a timer callback (see the"
" next section for an example)."
msgstr ""
"L'échec du premier point entraînera toujours une impasse. Un exemple d'un "
"tel cas serait de faire un appel de service synchrone dans un rappel de "
"temporisateur (voir la section suivante pour un exemple)."

#: ../../source/How-To-Guides/Using-callback-groups.rst:180
msgid "Examples"
msgstr "Exemples"

#: ../../source/How-To-Guides/Using-callback-groups.rst:182
msgid ""
"Let us look at some simple examples of different callback group setups. The "
"following demo code considers calling a service synchronously in a timer "
"callback."
msgstr ""
"Examinons quelques exemples simples de différentes configurations de groupes"
" de rappel. Le code de démonstration suivant considère l'appel d'un service "
"de manière synchrone dans un rappel de minuterie."

#: ../../source/How-To-Guides/Using-callback-groups.rst:187
msgid "Demo code"
msgstr "Code démo"

#: ../../source/How-To-Guides/Using-callback-groups.rst:189
msgid "We have two nodes - one providing a simple service:"
msgstr "Nous avons deux nœuds - l'un fournissant un service simple :"

#: ../../source/How-To-Guides/Using-callback-groups.rst:274
msgid ""
"and another containing a client to the service along with a timer for making"
" service calls:"
msgstr ""
"et un autre contenant un client au service avec une minuterie pour effectuer"
" des appels de service :"

#: ../../source/How-To-Guides/Using-callback-groups.rst:281
msgid ""
"*Note:* The API of service client in rclcpp does not offer a synchronous "
"call method similar to the one in rclpy, so we wait on the future object to "
"simulate the effect of a synchronous call."
msgstr ""
"*Remarque :* L'API du client de service dans rclcpp n'offre pas de méthode "
"d'appel synchrone similaire à celle de rclpy, nous attendons donc que le "
"futur objet simule l'effet d'un appel synchrone."

#: ../../source/How-To-Guides/Using-callback-groups.rst:384
msgid ""
"The client node's constructor contains options for setting the callback "
"groups of the service client and the timer. With the default setting above "
"(both being ``nullptr`` / ``None``), both the timer and the client will use "
"the node's default Mutually Exclusive Callback Group."
msgstr ""
"Le constructeur du nœud client contient des options pour définir les groupes"
" de rappel du client de service et le temporisateur. Avec le paramètre par "
"défaut ci-dessus (les deux étant ``nullptr`` / ``None``), le temporisateur "
"et le client utiliseront le groupe de rappel mutuellement exclusif par "
"défaut du nœud."

#: ../../source/How-To-Guides/Using-callback-groups.rst:391
msgid "The problem"
msgstr "Le problème"

#: ../../source/How-To-Guides/Using-callback-groups.rst:393
msgid ""
"Since we are making service calls with a 1 second timer, the expected "
"outcome is that the service gets called once a second, the client always "
"gets a response and prints ``Received response``. If we try running the "
"server and client nodes in terminals, we get the following outputs."
msgstr ""
"Étant donné que nous effectuons des appels de service avec une minuterie de "
"1 seconde, le résultat attendu est que le service est appelé une fois par "
"seconde, le client reçoit toujours une réponse et imprime ``Réponse reçue``."
" Si nous essayons d'exécuter les nœuds serveur et client dans les terminaux,"
" nous obtenons les sorties suivantes."

#: ../../source/How-To-Guides/Using-callback-groups.rst:401
#: ../../source/How-To-Guides/Using-callback-groups.rst:464
msgid "Client"
msgstr "Client"

#: ../../source/How-To-Guides/Using-callback-groups.rst:409
#: ../../source/How-To-Guides/Using-callback-groups.rst:479
msgid "Server"
msgstr "Serveur"

#: ../../source/How-To-Guides/Using-callback-groups.rst:417
msgid ""
"So, it turns out that instead of the service being called repeatedly, the "
"response of the first call is never received, after which the client node "
"seemingly gets stuck and does not make further calls. That is, the execution"
" stopped at a deadlock!"
msgstr ""
"Ainsi, il s'avère qu'au lieu que le service soit appelé à plusieurs "
"reprises, la réponse du premier appel n'est jamais reçue, après quoi le nœud"
" client semble bloqué et ne passe plus d'appels. Autrement dit, l'exécution "
"s'est arrêtée dans une impasse!"

#: ../../source/How-To-Guides/Using-callback-groups.rst:422
msgid ""
"The reason for this is that the timer callback and the client are using the "
"same Mutually Exclusive Callback Group (the node's default). When the "
"service call is made, the client then passes its callback group to the "
"Future object (hidden inside the call-method in the Python version) whose "
"done-callback needs to execute for the result of the service call to be "
"available. But because this done-callback and the timer callback are in the "
"same Mutually Exclusive group and the timer callback is still executing "
"(waiting for the result of the service call), the done-callback never gets "
"to execute. The stuck timer callback also blocks any other executions of "
"itself, so the timer does not fire for a second time."
msgstr ""
"La raison en est que le rappel du minuteur et le client utilisent le même "
"groupe de rappel mutuellement exclusif (la valeur par défaut du nœud). "
"Lorsque l'appel de service est effectué, le client passe alors son groupe de"
" rappel à l'objet Future (caché à l'intérieur de la méthode d'appel dans la "
"version Python) dont le rappel terminé doit s'exécuter pour que le résultat "
"de l'appel de service soit disponible. Mais comme ce rappel terminé et le "
"rappel de minuterie se trouvent dans le même groupe mutuellement exclusif et"
" que le rappel de minuterie est toujours en cours d'exécution (en attente du"
" résultat de l'appel de service), le rappel terminé ne s'exécute jamais. Le "
"rappel de la minuterie bloquée bloque également toutes les autres exécutions"
" de lui-même, de sorte que la minuterie ne se déclenche pas une deuxième "
"fois."

#: ../../source/How-To-Guides/Using-callback-groups.rst:436
msgid "Solution"
msgstr "Solution"

#: ../../source/How-To-Guides/Using-callback-groups.rst:438
msgid ""
"We can fix this easily - for example - by assigning the timer and client to "
"different callback groups. Thus, let us change the first two lines of the "
"client node's constructor to be as follows (everything else shall stay the "
"same):"
msgstr ""
"Nous pouvons résoudre ce problème facilement - par exemple - en affectant le"
" minuteur et le client à différents groupes de rappel. Ainsi, changeons les "
"deux premières lignes du constructeur du nœud client comme suit (tout le "
"reste doit rester le même) :"

#: ../../source/How-To-Guides/Using-callback-groups.rst:459
msgid ""
"Now we get the expected result, i.e. the timer fires repeatedly and each "
"service call gets the result as it should:"
msgstr ""
"Nous obtenons maintenant le résultat attendu, c'est-à-dire que la minuterie "
"se déclenche à plusieurs reprises et chaque appel de service obtient le "
"résultat comme il se doit :"

#: ../../source/How-To-Guides/Using-callback-groups.rst:490
msgid ""
"One might consider if just avoiding the node's default callback group is "
"enough. This is not the case: replacing the default group by a different "
"Mutually Exclusive group changes nothing. Thus, the following configuration "
"also leads to the previously discovered deadlock."
msgstr ""
"On pourrait se demander s'il suffit d'éviter le groupe de rappel par défaut "
"du nœud. Ce n'est pas le cas : remplacer le groupe par défaut par un autre "
"groupe mutuellement exclusif ne change rien. Ainsi, la configuration "
"suivante conduit également au blocage découvert précédemment."

#: ../../source/How-To-Guides/Using-callback-groups.rst:513
msgid ""
"In fact, the exact condition with which everything works in this case is "
"that the timer and client must not belong to the same Mutually Exclusive "
"group. Hence, all of the following configurations (and some others as well) "
"produce the desired outcome where the timer fires repeatedly and service "
"calls are completed."
msgstr ""
"En fait, la condition exacte avec laquelle tout fonctionne dans ce cas est "
"que la minuterie et le client ne doivent pas appartenir au même groupe "
"mutuellement exclusif. Par conséquent, toutes les configurations suivantes "
"(ainsi que certaines autres) produisent le résultat souhaité, dans lequel la"
" minuterie se déclenche à plusieurs reprises et les appels de service sont "
"terminés."

#: ../../source/How-To-Guides/Using-callback-groups.rst:529
#: ../../source/How-To-Guides/Using-callback-groups.rst:536
#: ../../source/How-To-Guides/Using-callback-groups.rst:543
#: ../../source/How-To-Guides/Using-callback-groups.rst:557
#: ../../source/How-To-Guides/Using-callback-groups.rst:564
#: ../../source/How-To-Guides/Using-callback-groups.rst:571
msgid "or"
msgstr "ou alors"
