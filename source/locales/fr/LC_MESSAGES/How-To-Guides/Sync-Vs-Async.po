# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, Open Robotics
# This file is distributed under the same license as the ROS 2 documentation package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: ROS 2 documentation\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-01-07 08:44+0100\n"
"PO-Revision-Date: 2023-01-07 17:22:05.955423\n"
"Last-Translator: potranslator 1.1.5\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Translated-By: potranslator 1.1.5\n"

#: ../../source/How-To-Guides/Sync-Vs-Async.rst:9
msgid "Synchronous vs. asynchronous service clients"
msgstr "Clients de service synchrones ou asynchrones"

#: ../../source/How-To-Guides/Sync-Vs-Async.rst:11
msgid "**Level:** Intermediate"
msgstr "**Niveau :** Intermédiaire"

#: ../../source/How-To-Guides/Sync-Vs-Async.rst:13
msgid "**Time:** 10 minutes"
msgstr "**Durée :** 10 minutes"

#: ../../source/How-To-Guides/Sync-Vs-Async.rst:18
msgid "Contents"
msgstr "Contenu"

#: ../../source/How-To-Guides/Sync-Vs-Async.rst:21
msgid "Introduction"
msgstr "Introduction"

#: ../../source/How-To-Guides/Sync-Vs-Async.rst:23
msgid ""
"This guide is intended to warn users of the risks associated with the Python"
" synchronous service client ``call()`` API. It is very easy to mistakenly "
"cause deadlock when calling services synchronously, so we do not recommend "
"using ``call()``."
msgstr ""
"Ce guide est destiné à avertir les utilisateurs des risques associés à l'API"
" ``call()`` du client de service synchrone Python. Il est très facile de "
"provoquer par erreur un interblocage lors de l'appel de services de manière "
"synchrone, nous ne recommandons donc pas d'utiliser ``call()``."

#: ../../source/How-To-Guides/Sync-Vs-Async.rst:26
msgid ""
"We provide an example on how to use ``call()`` correctly for experienced "
"users who wish to use synchronous calls and are aware of the pitfalls. We "
"also highlight possible scenarios for deadlock that accompany it."
msgstr ""
"Nous fournissons un exemple sur la façon d'utiliser correctement ``call()`` "
"pour les utilisateurs expérimentés qui souhaitent utiliser des appels "
"synchrones et sont conscients des pièges. Nous mettons également en évidence"
" les scénarios possibles de blocage qui l'accompagnent."

#: ../../source/How-To-Guides/Sync-Vs-Async.rst:29
msgid ""
"Because we recommend avoiding sync calls, this guide will also address the "
"features and usage of the recommended alternative, async calls "
"(``call_async()``)."
msgstr ""
"Étant donné que nous recommandons d'éviter les appels de synchronisation, ce"
" guide abordera également les fonctionnalités et l'utilisation de "
"l'alternative recommandée, les appels asynchrones (``call_async()``)."

#: ../../source/How-To-Guides/Sync-Vs-Async.rst:31
msgid ""
"The C++ service call API is only available in async, so the comparisons and "
"examples in this guide pertain to Python services and clients. The "
"definition of async given here generally applies to C++, with some "
"exceptions."
msgstr ""
"L'API d'appel de service C++ n'est disponible qu'en mode asynchrone, de "
"sorte que les comparaisons et les exemples de ce guide concernent les "
"services et les clients Python. La définition d'async donnée ici s'applique "
"généralement à C++, à quelques exceptions près."

#: ../../source/How-To-Guides/Sync-Vs-Async.rst:35
msgid "1 Synchronous calls"
msgstr "1 Appels synchrones"

#: ../../source/How-To-Guides/Sync-Vs-Async.rst:37
msgid ""
"A synchronous client will block the calling thread when sending a request to"
" a service until a response has been received; nothing else can happen on "
"that thread during the call. The call can take arbitrary amounts of time to "
"complete. Once complete, the response returns directly to the client."
msgstr ""
"Un client synchrone bloquera le thread appelant lors de l'envoi d'une "
"requête à un service jusqu'à ce qu'une réponse ait été reçue ; rien d'autre "
"ne peut se produire sur ce fil pendant l'appel. L'appel peut prendre un "
"temps arbitraire pour se terminer. Une fois terminée, la réponse revient "
"directement au client."

#: ../../source/How-To-Guides/Sync-Vs-Async.rst:41
msgid ""
"The following is an example of how to correctly execute a synchronous "
"service call from a client node, similar to the async node in the "
":doc:`Simple Service and Client <../Tutorials/Beginner-Client-"
"Libraries/Writing-A-Simple-Py-Publisher-And-Subscriber>` tutorial."
msgstr ""
"Voici un exemple d'exécution correcte d'un appel de service synchrone à "
"partir d'un nœud client, similaire au nœud asynchrone dans :doc:`Simple "
"Service and Client <../Tutorials/Beginner-Client-Libraries/Writing-A- "
"Tutoriel Simple-Py-Publisher-And-Subscriber>`."

#: ../../source/How-To-Guides/Sync-Vs-Async.rst:88
msgid ""
"Note inside ``main()`` that the client calls ``rclpy.spin`` in a separate "
"thread. Both ``send_request`` and ``rclpy.spin`` are blocking, so they need "
"to be on separate threads."
msgstr ""
"Notez dans ``main()`` que le client appelle ``rclpy.spin`` dans un thread "
"séparé. ``send_request`` et ``rclpy.spin`` sont bloquants, ils doivent donc "
"être sur des threads séparés."

#: ../../source/How-To-Guides/Sync-Vs-Async.rst:92
msgid "1.1 Sync deadlock"
msgstr "1.1 Blocage de synchronisation"

#: ../../source/How-To-Guides/Sync-Vs-Async.rst:94
msgid ""
"There are several ways that the synchronous ``call()`` API can cause "
"deadlock."
msgstr ""
"L'API synchrone ``call()`` peut provoquer un blocage de plusieurs manières."

#: ../../source/How-To-Guides/Sync-Vs-Async.rst:96
msgid ""
"As mentioned in the comments of the example above, failing to create a "
"separate thread to spin ``rclpy`` is one cause of deadlock. When a client is"
" blocking a thread waiting for a response, but the response can only be "
"returned on that same thread, the client will never stop waiting, and "
"nothing else can happen."
msgstr ""
"Comme mentionné dans les commentaires de l'exemple ci-dessus, ne pas créer "
"un thread séparé pour lancer ``rclpy`` est une cause de blocage. Lorsqu'un "
"client bloque un thread en attente d'une réponse, mais que la réponse ne "
"peut être renvoyée que sur ce même thread, le client n'arrêtera jamais "
"d'attendre et rien d'autre ne peut se produire."

#: ../../source/How-To-Guides/Sync-Vs-Async.rst:99
msgid ""
"Another cause of deadlock is blocking ``rclpy.spin`` by calling a service "
"synchronously in a subscription, timer callback or service callback. For "
"example, if the synchronous client's ``send_request`` is placed in a "
"callback:"
msgstr ""
"Une autre cause de blocage est le blocage de ``rclpy.spin`` en appelant un "
"service de manière synchrone dans un abonnement, un rappel de minuterie ou "
"un rappel de service. Par exemple, si la ``send_request`` du client "
"synchrone est placée dans un rappel :"

#: ../../source/How-To-Guides/Sync-Vs-Async.rst:113
msgid ""
"Deadlock occurs because ``rclpy.spin`` will not preempt the callback with "
"the ``send_request`` call. In general, callbacks should only perform light "
"and fast operations."
msgstr ""
"L'interblocage se produit car ``rclpy.spin`` ne préemptera pas le rappel "
"avec l'appel ``send_request``. En général, les rappels ne doivent effectuer "
"que des opérations légères et rapides."

#: ../../source/How-To-Guides/Sync-Vs-Async.rst:118
msgid ""
"When deadlock occurs, you will not receive any indication that the service "
"is blocked. There will be no warning or exception thrown, no indication in "
"the stack trace, and the call will not fail."
msgstr ""
"En cas d'interblocage, vous ne recevrez aucune indication indiquant que le "
"service est bloqué. Il n'y aura pas d'avertissement ou d'exception levée, "
"aucune indication dans la trace de la pile et l'appel n'échouera pas."

#: ../../source/How-To-Guides/Sync-Vs-Async.rst:122
msgid "2 Asynchronous calls"
msgstr "2 appels asynchrones"

#: ../../source/How-To-Guides/Sync-Vs-Async.rst:124
msgid ""
"Async calls in ``rclpy`` are entirely safe and the recommended method of "
"calling services. They can be made from anywhere without running the risk of"
" blocking other ROS and non-ROS processes, unlike sync calls."
msgstr ""
"Les appels asynchrones dans ``rclpy`` sont entièrement sûrs et constituent "
"la méthode recommandée pour appeler les services. Ils peuvent être effectués"
" depuis n'importe où sans courir le risque de bloquer d'autres processus ROS"
" et non ROS, contrairement aux appels de synchronisation."

#: ../../source/How-To-Guides/Sync-Vs-Async.rst:127
msgid ""
"An asynchronous client will immediately return ``future``, a value that "
"indicates whether the call and response is finished (not the value of the "
"response itself), after sending a request to a service. The returned "
"``future`` may be queried for a response at any time."
msgstr ""
"Un client asynchrone retournera immédiatement ``future``, une valeur qui "
"indique si l'appel et la réponse sont terminés (pas la valeur de la réponse "
"elle-même), après avoir envoyé une requête à un service. Le ``futur`` "
"retourné peut être interrogé pour une réponse à tout moment."

#: ../../source/How-To-Guides/Sync-Vs-Async.rst:130
msgid ""
"Since sending a request doesn’t block anything, a loop can be used to both "
"spin ``rclpy`` and check ``future`` in the same thread, for example:"
msgstr ""
"Étant donné que l'envoi d'une requête ne bloque rien, une boucle peut être "
"utilisée à la fois pour faire tourner ``rclpy`` et vérifier ``future`` dans "
"le même thread, par exemple :"

#: ../../source/How-To-Guides/Sync-Vs-Async.rst:139
msgid ""
"The :doc:`Simple Service and Client <../Tutorials/Beginner-Client-"
"Libraries/Writing-A-Simple-Py-Publisher-And-Subscriber>` tutorial for Python"
" illustrates how to perform an async service call and retrieve the "
"``future`` using a loop."
msgstr ""
"Le didacticiel :doc:`Simple Service and Client <../Tutorials/Beginner-"
"Client-Libraries/Writing-A-Simple-Py-Publisher-And-Subscriber>` pour Python "
"illustre comment effectuer un appel de service asynchrone et récupérer le "
"``futur`` en utilisant une boucle."

#: ../../source/How-To-Guides/Sync-Vs-Async.rst:141
msgid ""
"The ``future`` can also be retrieved using a timer or callback, like in "
"`this example "
"<https://github.com/ros2/examples/blob/rolling/rclpy/services/minimal_client/examples_rclpy_minimal_client/client_async_callback.py>`_,"
" a dedicated thread, or by another method. It is up to you, as the caller, "
"to decide how to store ``future``, check on its status, and retrieve your "
"response."
msgstr ""
"Le ``futur`` peut également être récupéré à l'aide d'un minuteur ou d'un "
"rappel, comme dans `cet exemple "
"<https://github.com/ros2/examples/blob/rolling/rclpy/services/minimal_client/examples_rclpy_minimal_client/client_async_callback.py>"
" `_, un thread dédié, ou par une autre méthode. C'est à vous, en tant "
"qu'appelant, de décider comment stocker ``future``, vérifier son statut et "
"récupérer votre réponse."

#: ../../source/How-To-Guides/Sync-Vs-Async.rst:145
msgid "Summary"
msgstr "Résumé"

#: ../../source/How-To-Guides/Sync-Vs-Async.rst:147
msgid ""
"It is not recommended to implement a synchronous service client. They are "
"susceptible to deadlock, but will not provide any indication of issue when "
"deadlock occurs. If you must use synchronous calls, the example in section "
"`1 Synchronous calls`_ is a safe method of doing so. You should also be "
"aware of the conditions that cause deadlock outlined in section `1.1 Sync "
"deadlock`_. We recommend using async service clients instead."
msgstr ""
"Il n'est pas recommandé d'implémenter un client de service synchrone. Ils "
"sont susceptibles de se bloquer, mais ne fourniront aucune indication de "
"problème en cas de blocage. Si vous devez utiliser des appels synchrones, "
"l'exemple de la section `1 Appels synchrones`_ est une méthode sûre pour le "
"faire. Vous devez également être conscient des conditions qui provoquent un "
"blocage décrites dans la section `1.1 Blocage de synchronisation`_. Nous "
"vous recommandons d'utiliser plutôt des clients de service asynchrones."
